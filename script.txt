//@version=6
strategy("Crypto Farm BBB3", overlay=true, 
     initial_capital=10000, 
     default_qty_type=strategy.percent_of_equity, 
     default_qty_value=100,
     commission_type=strategy.commission.percent, 
     commission_value=0.1,
     slippage=2,
     calc_on_every_tick=true,
     process_orders_on_close=true,
     calc_on_order_fills=false)

// ═══════════════════════════════════════════════════════════════════════════
// INPUT PARAMETERS
// ═══════════════════════════════════════════════════════════════════════════

// Bollinger Bands Settings
bb_length = input.int(20, "BB Length", minval=1, group="Bollinger Bands")
bb_mult = input.float(2.0, "BB Multiplier", minval=0.1, step=0.1, group="Bollinger Bands")
bb_source = input.source(close, "BB Source", group="Bollinger Bands")

// Mode Selection
mode = input.string("Wide Tide", "Trading Mode", 
     options=["Wide Tide", "Distance Capture"], group="Strategy Mode")

// Wide Tide Settings
wt_threshold = input.float(2.5, "Wide Tide Threshold (%)", minval=0.1, step=0.1, group="Wide Tide Mode")

// Distance Capture Settings
dc_entry_pct = input.float(25.0, "Distance Capture Entry %", minval=0, maxval=100, step=1, group="Distance Capture Mode")

// BROC Filter Settings
use_broc = input.bool(true, "Use BROC Filter", group="BROC Filter")
broc_length = input.int(14, "BROC Length", minval=1, group="BROC Filter")
broc_threshold = input.float(0.5, "BROC Threshold (degrees)", minval=0, step=0.1, group="BROC Filter")
broc_multiplier = input.float(1.0, "BROC Scaling Multiplier", minval=0.1, maxval=10, step=0.1, group="BROC Filter")

// Extra Filters Settings
use_uproc = input.bool(false, "Use UPROC Filter", group="Extra Filters")
uproc_length = input.int(14, "UPROC Length", minval=1, group="Extra Filters")
uproc_threshold = input.float(0.5, "UPROC Threshold (degrees)", minval=0, step=0.1, group="Extra Filters")
uproc_multiplier = input.float(1.0, "UPROC Scaling Multiplier", minval=0.1, maxval=10, step=0.1, group="Extra Filters")

use_loroc = input.bool(false, "Use LOROC Filter", group="Extra Filters")
loroc_length = input.int(14, "LOROC Length", minval=1, group="Extra Filters")
loroc_threshold = input.float(0.5, "LOROC Threshold (degrees)", minval=0, step=0.1, group="Extra Filters")
loroc_multiplier = input.float(1.0, "LOROC Scaling Multiplier", minval=0.1, maxval=10, step=0.1, group="Extra Filters")

use_marubozu = input.bool(false, "Use Marubozu Filter", group="Extra Filters")
marubozu_body_pct = input.float(70.0, "Marubozu Body % of Range", minval=50, maxval=100, step=1, group="Extra Filters")
marubozu_wick_pct = input.float(15.0, "Marubozu Max Wick % of Body", minval=0, maxval=50, step=1, group="Extra Filters")

// Cooldown Settings
use_cooldown = input.bool(false, "Enable Cooldown", group="Cooldown")
cooldown_type = input.string("Candles", "Cooldown Type", options=["Candles", "Time"], group="Cooldown")
cooldown_candles = input.int(5, "Cooldown Candles", minval=1, group="Cooldown")
cooldown_minutes = input.int(60, "Cooldown Minutes", minval=1, group="Cooldown")
cooldown_applies_to = input.string("Same Direction", "Apply To", 
     options=["Same Direction", "Both Directions"], group="Cooldown")

// ScoopTime Settings
use_scooptime = input.bool(false, "Enable ScoopTime", group="ScoopTime")
scoop_seconds = input.int(30, "Seconds Before Close", minval=1, maxval=3600, group="ScoopTime")

// Delay Entry Settings
use_delay = input.bool(false, "Enable Delay Entry", group="Delay Entry")
delay_candles = input.int(1, "Delay Candles", minval=1, maxval=50, group="Delay Entry")

// Take Profit Settings
use_tp1 = input.bool(true, "Enable TP1", group="Take Profit")
tp1_pct = input.float(2.0, "TP1 %", minval=0.1, step=0.1, group="Take Profit")
tp1_candles = input.int(0, "TP1 Max Candles (0=disabled)", minval=0, group="Take Profit")

use_tp2 = input.bool(true, "Enable TP2", group="Take Profit")
tp2_pct = input.float(4.0, "TP2 %", minval=0.1, step=0.1, group="Take Profit")
tp2_candles = input.int(0, "TP2 Max Candles (0=disabled)", minval=0, group="Take Profit")

move_sl_to_be = input.bool(true, "Move SL to Breakeven after TP1", group="Take Profit")

// Stop Loss Settings
sl_pct = input.float(1.5, "Stop Loss %", minval=0.1, step=0.1, group="Stop Loss")

// Redundancy Probes Settings
use_probes = input.bool(false, "Enable Redundancy Probes", group="Redundancy Probes")
time_between_probes = input.int(60, "Time Between Probes (seconds)", minval=1, group="Redundancy Probes")

// Trade Direction
trade_direction = input.string("Both", "Trade Direction", options=["Long", "Short", "Both"], group="Trade Settings")

// Signal Settings for Alerts
signal_prefix_mode = input.string("WT", "Mode Prefix", group="Signal Settings", tooltip="e.g., WT for Wide Tide, DC for Distance Capture")
signal_prefix_custom = input.string("BBB3", "Custom Prefix", group="Signal Settings", tooltip="Your custom identifier")
signal_start_number = input.int(1, "Start Trade Number", minval=1, group="Signal Settings")
use_custom_alerts = input.bool(true, "Enable Custom Alert Messages", group="Signal Settings")

// ═══════════════════════════════════════════════════════════════════════════
// ALERT MESSAGE FORMAT INPUTS (for automation)
// ═══════════════════════════════════════════════════════════════════════════
alert_token = input.string("YOUR_TOKEN", "Alert Token", group="Signal Settings", tooltip="Paste your automation token here")
pair_override = input.string("BTCUSD", "Pair Override", group="Signal Settings", tooltip="Override symbol for alert message")
risk_lots = input.float(1.0, "Risk Lots", minval=0.01, step=0.01, group="Signal Settings", tooltip="Risk lots for automation")

// ═══════════════════════════════════════════════════════════════════════════
// GLOBAL VARIABLES & ARRAYS FOR STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════

// Delayed entry tracking
var int delayed_long_bar = na
var int delayed_short_bar = na
var float delayed_long_price = na
var float delayed_short_price = na

// TP tracking
var float entry_price = na
var bool tp1_hit = false
var int trade_entry_bar = na

// Probe tracking
var int last_probe_time = na
var bool probes_active = false
var string last_trade_direction = ""

// Cooldown tracking
var int last_long_trade_bar = na
var int last_short_trade_bar = na
var int last_long_trade_time = na
var int last_short_trade_time = na

// Trade ID tracking
var int trade_counter = signal_start_number
var string current_trade_id = ""
var string current_position_side = ""

// TP/SL level variables - declared globally
var float long_tp1 = na
var float long_tp2 = na
var float long_sl = na
var float short_tp1 = na
var float short_tp2 = na
var float short_sl = na

// Alert trigger flags (persist across bars, reset each bar)
var bool entry_long_trigger = false
var bool entry_short_trigger = false
var bool tp1_exit_trigger = false
var bool tp2_exit_trigger = false
var bool sl_exit_trigger = false
var bool position_opened_trigger = false
var bool position_closed_trigger = false
var bool sl_moved_to_be_trigger = false

// ═══════════════════════════════════════════════════════════════════════════
// BOLLINGER BANDS CALCULATION
// ═══════════════════════════════════════════════════════════════════════════

[bb_middle, bb_upper, bb_lower] = ta.bb(bb_source, bb_length, bb_mult)

// Plot Bollinger Bands
plot(bb_upper, "Upper Band", color=color.new(color.blue, 0), linewidth=1)
plot(bb_middle, "Basis", color=color.new(color.orange, 0), linewidth=1)
plot(bb_lower, "Lower Band", color=color.new(color.blue, 0), linewidth=1)

// ═══════════════════════════════════════════════════════════════════════════
// BROC (BASIS RATE OF CHANGE) CALCULATION
// ═══════════════════════════════════════════════════════════════════════════

// Calculate basis change
basis_change = bb_middle - bb_middle[broc_length]

// Calculate price range for normalization (prevents division by zero)
price_range = math.max(high - low, 0.0001)

// Convert slope to angle using arctan
// Formula: angle = atan(rise/run) * (180/π)
// rise = basis_change, run = broc_length * average_price_range
average_range = ta.sma(price_range, broc_length)
slope_ratio = basis_change / (broc_length * average_range)

// Convert to degrees and apply multiplier
broc_angle = math.atan(slope_ratio) * (180 / math.pi) * broc_multiplier

// BROC filter conditions
broc_bullish = not use_broc or broc_angle > broc_threshold
broc_bearish = not use_broc or broc_angle < -broc_threshold

// ═══════════════════════════════════════════════════════════════════════════
// UPROC (UPPER BAND RATE OF CHANGE) CALCULATION
// ═══════════════════════════════════════════════════════════════════════════

// Calculate upper band change
upper_change = bb_upper - bb_upper[uproc_length]

// Convert slope to angle using arctan
average_range_uproc = ta.sma(price_range, uproc_length)
slope_ratio_uproc = upper_change / (uproc_length * average_range_uproc)

// Convert to degrees and apply multiplier
uproc_angle = math.atan(slope_ratio_uproc) * (180 / math.pi) * uproc_multiplier

// UPROC filter conditions
uproc_bullish = not use_uproc or uproc_angle > uproc_threshold
uproc_bearish = not use_uproc or uproc_angle < -uproc_threshold

// ═══════════════════════════════════════════════════════════════════════════
// LOROC (LOWER BAND RATE OF CHANGE) CALCULATION
// ═══════════════════════════════════════════════════════════════════════════

// Calculate lower band change
lower_change = bb_lower - bb_lower[loroc_length]

// Convert slope to angle using arctan
average_range_loroc = ta.sma(price_range, loroc_length)
slope_ratio_loroc = lower_change / (loroc_length * average_range_loroc)

// Convert to degrees and apply multiplier
loroc_angle = math.atan(slope_ratio_loroc) * (180 / math.pi) * loroc_multiplier

// LOROC filter conditions
loroc_bullish = not use_loroc or loroc_angle > loroc_threshold
loroc_bearish = not use_loroc or loroc_angle < -loroc_threshold

// ═══════════════════════════════════════════════════════════════════════════
// MARUBOZU FILTER
// ═══════════════════════════════════════════════════════════════════════════

// Calculate candle properties
candle_range = high - low
candle_body = math.abs(close - open)
upper_wick = high - math.max(open, close)
lower_wick = math.min(open, close) - low

// Marubozu conditions
// Body must be at least X% of total range
body_to_range_pct = candle_range > 0 ? (candle_body / candle_range) * 100 : 0
is_strong_body = body_to_range_pct >= marubozu_body_pct

// Wicks must be small relative to body
upper_wick_to_body_pct = candle_body > 0 ? (upper_wick / candle_body) * 100 : 0
lower_wick_to_body_pct = candle_body > 0 ? (lower_wick / candle_body) * 100 : 0
has_small_wicks = upper_wick_to_body_pct <= marubozu_wick_pct and 
     lower_wick_to_body_pct <= marubozu_wick_pct

// Bullish Marubozu: strong bullish body with small wicks
is_bullish_marubozu = close > open and is_strong_body and has_small_wicks

// Bearish Marubozu: strong bearish body with small wicks
is_bearish_marubozu = close < open and is_strong_body and has_small_wicks

// Marubozu filter conditions
marubozu_bullish = not use_marubozu or is_bullish_marubozu
marubozu_bearish = not use_marubozu or is_bearish_marubozu

// ═══════════════════════════════════════════════════════════════════════════
// SCOOPTIME LOGIC - BAR-STABLE IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════

// Calculate timeframe in seconds
tf_seconds = timeframe.in_seconds()

// Determine if we're within scoop window
// We check if the bar is close enough to closing based on bar time
// For bar-stable behavior, we trigger on the LAST bar before close
bars_until_close = math.floor(scoop_seconds / tf_seconds)
is_scoop_time = use_scooptime ? (bars_until_close <= 1) : true

// ═══════════════════════════════════════════════════════════════════════════
// WIDE TIDE MODE LOGIC
// ═══════════════════════════════════════════════════════════════════════════

bb_width = bb_upper - bb_lower
bb_width_pct = (bb_width / bb_middle) * 100

wide_tide_long = bb_width_pct > wt_threshold and close < bb_lower
wide_tide_short = bb_width_pct > wt_threshold and close > bb_upper

// ═══════════════════════════════════════════════════════════════════════════
// DISTANCE CAPTURE MODE LOGIC
// ═══════════════════════════════════════════════════════════════════════════

// Calculate distance from price to bands
distance_to_lower = bb_middle - bb_lower
distance_to_upper = bb_upper - bb_middle

// Calculate entry points based on percentage
dc_long_level = bb_lower + (distance_to_lower * (dc_entry_pct / 100))
dc_short_level = bb_upper - (distance_to_upper * (dc_entry_pct / 100))

distance_capture_long = close <= dc_long_level
distance_capture_short = close >= dc_short_level

// ═══════════════════════════════════════════════════════════════════════════
// ALERT MESSAGE GENERATION
// ═══════════════════════════════════════════════════════════════════════════

// Generate unique trade ID
generate_trade_id(action) =>
    signal_prefix_mode + "-" + str.format("{0,number,00000}", trade_counter) + "-" + action

// Create alert message in Crypto Farm format (flat key=value pairs)
create_alert_message(signal, trade_id, sl_pct, tp_pct) =>
    'token=' + alert_token + ',signal=' + signal + ',symbol=' + pair_override + ',risk_lots=' + str.tostring(risk_lots) + ',sl_pct=' + str.tostring(sl_pct) + ',tp_pct=' + str.tostring(tp_pct) + ',comment=' + trade_id + ',trid=' + trade_id

// Create closeall/probe alert message
create_close_alert_message(trade_id) =>
    'token=' + alert_token + ',signal=closeall,symbol=' + pair_override + ',trid=' + trade_id

// Create move SL to BE alert message
create_move_sl_be_message(trade_id, is_long) =>
    'token=' + alert_token + ',signal=' + (is_long ? 'newsltplong' : 'newsltpshort') + ',symbol=' + pair_override + ',sl=0,trid=' + trade_id

// ═══════════════════════════════════════════════════════════════════════════
// COOLDOWN SYSTEM
// ═══════════════════════════════════════════════════════════════════════════

// Calculate if cooldown period has passed
cooldown_long_ok = true
cooldown_short_ok = true

if use_cooldown
    if cooldown_type == "Candles"
        // Candle-based cooldown
        if cooldown_applies_to == "Same Direction"
            cooldown_long_ok := na(last_long_trade_bar) or 
                 (bar_index - last_long_trade_bar >= cooldown_candles)
            cooldown_short_ok := na(last_short_trade_bar) or 
                 (bar_index - last_short_trade_bar >= cooldown_candles)
        else // Both Directions
            bars_since_last = na(last_long_trade_bar) and na(last_short_trade_bar) ? 
                 999999 : 
                 math.min(
                     na(last_long_trade_bar) ? 999999 : bar_index - last_long_trade_bar,
                     na(last_short_trade_bar) ? 999999 : bar_index - last_short_trade_bar
                 )
            cooldown_long_ok := bars_since_last >= cooldown_candles
            cooldown_short_ok := bars_since_last >= cooldown_candles
    else // Time-based cooldown
        cooldown_seconds = cooldown_minutes * 60
        
        if cooldown_applies_to == "Same Direction"
            time_since_long = na(last_long_trade_time) ? 
                 999999999 : (time - last_long_trade_time) / 1000
            time_since_short = na(last_short_trade_time) ? 
                 999999999 : (time - last_short_trade_time) / 1000
            
            cooldown_long_ok := time_since_long >= cooldown_seconds
            cooldown_short_ok := time_since_short >= cooldown_seconds
        else // Both Directions
            time_since_last = na(last_long_trade_time) and na(last_short_trade_time) ? 
                 999999999 :
                 math.min(
                     na(last_long_trade_time) ? 999999999 : (time - last_long_trade_time) / 1000,
                     na(last_short_trade_time) ? 999999999 : (time - last_short_trade_time) / 1000
                 )
            cooldown_long_ok := time_since_last >= cooldown_seconds
            cooldown_short_ok := time_since_last >= cooldown_seconds

// ═══════════════════════════════════════════════════════════════════════════
// COMBINED ENTRY CONDITIONS
// ═══════════════════════════════════════════════════════════════════════════

// Mode selection
mode_long = mode == "Wide Tide" ? wide_tide_long : distance_capture_long
mode_short = mode == "Wide Tide" ? wide_tide_short : distance_capture_short

// Combine all filters
all_filters_long = broc_bullish and uproc_bullish and loroc_bullish and marubozu_bullish
all_filters_short = broc_bearish and uproc_bearish and loroc_bearish and marubozu_bearish

// Base entry signals with all filters
base_long_signal = mode_long and all_filters_long and is_scoop_time and cooldown_long_ok
base_short_signal = mode_short and all_filters_short and is_scoop_time and cooldown_short_ok

// Direction filter
can_long = trade_direction == "Long" or trade_direction == "Both"
can_short = trade_direction == "Short" or trade_direction == "Both"

long_signal = base_long_signal and can_long
short_signal = base_short_signal and can_short

// ═══════════════════════════════════════════════════════════════════════════
// Reset per-bar alert triggers (so they can be used by alertcondition)
// ═══════════════════════════════════════════════════════════════════════════
entry_long_trigger := false
entry_short_trigger := false
tp1_exit_trigger := false
tp2_exit_trigger := false
sl_exit_trigger := false
position_opened_trigger := false
position_closed_trigger := false
sl_moved_to_be_trigger := false

// ═══════════════════════════════════════════════════════════════════════════
// DELAY ENTRY SYSTEM
// ═══════════════════════════════════════════════════════════════════════════

// Store delayed entries
if use_delay and long_signal and strategy.position_size == 0
    delayed_long_bar := bar_index
    delayed_long_price := close
    delayed_short_bar := na

if use_delay and short_signal and strategy.position_size == 0
    delayed_short_bar := bar_index
    delayed_short_price := close
    delayed_long_bar := na

// Check if delay period has passed
delay_long_ready = use_delay and not na(delayed_long_bar) and 
     (bar_index - delayed_long_bar >= delay_candles)
delay_short_ready = use_delay and not na(delayed_short_bar) and 
     (bar_index - delayed_short_bar >= delay_candles)

// Final entry triggers
execute_long = use_delay ? delay_long_ready : long_signal
execute_short = use_delay ? delay_short_ready : short_signal

// ═══════════════════════════════════════════════════════════════════════════
// POSITION ENTRY
// ═══════════════════════════════════════════════════════════════════════════

if execute_long and strategy.position_size == 0
    // Generate unique trade ID
    current_trade_id := generate_trade_id("ENTRY")
    current_position_side := "LONG"
    
    // Store entry info
    entry_price := close
    tp1_hit := false
    trade_entry_bar := bar_index
    last_trade_direction := "long"
    
    // Calculate TP/SL levels immediately
    float temp_long_tp1 = entry_price * (1 + tp1_pct / 100)
    float temp_long_tp2 = entry_price * (1 + tp2_pct / 100)
    float temp_long_sl = entry_price * (1 - sl_pct / 100)
    
    long_tp1 := temp_long_tp1
    long_tp2 := temp_long_tp2
    long_sl := temp_long_sl
    
    // Update cooldown tracking
    last_long_trade_bar := bar_index
    last_long_trade_time := time
    
    // Execute entry
    strategy.entry("Long", strategy.long, comment=current_trade_id)
    entry_long_trigger := true
    position_opened_trigger := true
    // Send full info alert for automation
    alert(create_alert_message('buy', current_trade_id, sl_pct, tp1_pct), alert.freq_once_per_bar)
    
    // Increment trade counter
    trade_counter += 1
    
    // Clear delayed entry
    delayed_long_bar := na
    delayed_long_price := na

if execute_short and strategy.position_size == 0
    // Generate unique trade ID
    current_trade_id := generate_trade_id("ENTRY")
    current_position_side := "SHORT"
    
    // Store entry info
    entry_price := close
    tp1_hit := false
    trade_entry_bar := bar_index
    last_trade_direction := "short"
    
    // Calculate TP/SL levels immediately
    float temp_short_tp1 = entry_price * (1 - tp1_pct / 100)
    float temp_short_tp2 = entry_price * (1 - tp2_pct / 100)
    float temp_short_sl = entry_price * (1 + sl_pct / 100)
    
    short_tp1 := temp_short_tp1
    short_tp2 := temp_short_tp2
    short_sl := temp_short_sl
    
    // Update cooldown tracking
    last_short_trade_bar := bar_index
    last_short_trade_time := time
    
    // Execute entry
    strategy.entry("Short", strategy.short, comment=current_trade_id)
    entry_short_trigger := true
    position_opened_trigger := true
    // Send full info alert for automation
    alert(create_alert_message('sell', current_trade_id, sl_pct, tp1_pct), alert.freq_once_per_bar)
    
    // Increment trade counter
    trade_counter += 1
    
    // Clear delayed entry
    delayed_short_bar := na
    delayed_short_price := na

// ═══════════════════════════════════════════════════════════════════════════
// DUAL TAKE PROFIT SYSTEM
// ═══════════════════════════════════════════════════════════════════════════

// Update TP and SL levels for active positions
if strategy.position_size > 0 and not na(entry_price)
    long_tp1 := entry_price * (1 + tp1_pct / 100)
    long_tp2 := entry_price * (1 + tp2_pct / 100)
    long_sl := entry_price * (1 - sl_pct / 100)
    
    // Move SL to breakeven after TP1
    if tp1_hit and move_sl_to_be
        long_sl := entry_price
        sl_moved_to_be_trigger := true

if strategy.position_size < 0 and not na(entry_price)
    short_tp1 := entry_price * (1 - tp1_pct / 100)
    short_tp2 := entry_price * (1 - tp2_pct / 100)
    short_sl := entry_price * (1 + sl_pct / 100)
    
    // Move SL to breakeven after TP1
    if tp1_hit and move_sl_to_be
        short_sl := entry_price
        sl_moved_to_be_trigger := true

// Check candle count for time-based TPs
candles_in_trade = not na(trade_entry_bar) ? bar_index - trade_entry_bar : 0
tp1_time_exit = tp1_candles > 0 and candles_in_trade >= tp1_candles
tp2_time_exit = tp2_candles > 0 and candles_in_trade >= tp2_candles

// Variables for trade IDs in exits
var string tp1_trade_id = ""
var string tp2_trade_id = ""
var string sl_trade_id = ""
var float pnl = 0.0

// TP1 Exit Logic (Long)
if strategy.position_size > 0 and use_tp1 and not tp1_hit
    if high >= long_tp1 or tp1_time_exit
        tp1_hit := true
        tp1_trade_id := generate_trade_id("TPS1")
        pnl := ((long_tp1 - entry_price) / entry_price) * 100
        strategy.close("Long", qty_percent=50, comment=tp1_trade_id)
        tp1_exit_trigger := true
        alert(create_close_alert_message(tp1_trade_id), alert.freq_once_per_bar)

if strategy.position_size < 0 and use_tp1 and not tp1_hit
    if low <= short_tp1 or tp1_time_exit
        tp1_hit := true
        tp1_trade_id := generate_trade_id("TPS1")
        pnl := ((entry_price - short_tp1) / entry_price) * 100
        strategy.close("Short", qty_percent=50, comment=tp1_trade_id)
        tp1_exit_trigger := true
        alert(create_close_alert_message(tp1_trade_id), alert.freq_once_per_bar)

// TP2 Exit Logic (Long)
if strategy.position_size > 0 and use_tp2
    if high >= long_tp2 or tp2_time_exit
        tp2_trade_id := generate_trade_id("TPS2")
        pnl := ((long_tp2 - entry_price) / entry_price) * 100
        strategy.close("Long", comment=tp2_trade_id)
        tp2_exit_trigger := true
        alert(create_close_alert_message(tp2_trade_id), alert.freq_once_per_bar)

if strategy.position_size < 0 and use_tp2
    if low <= short_tp2 or tp2_time_exit
        tp2_trade_id := generate_trade_id("TPS2")
        pnl := ((entry_price - short_tp2) / entry_price) * 100
        strategy.close("Short", comment=tp2_trade_id)
        tp2_exit_trigger := true
        alert(create_close_alert_message(tp2_trade_id), alert.freq_once_per_bar)

// Stop Loss (Long)
if strategy.position_size > 0
    if low <= long_sl
        sl_trade_id := generate_trade_id("SL")
        pnl := ((long_sl - entry_price) / entry_price) * 100
        strategy.close("Long", comment=sl_trade_id)
        sl_exit_trigger := true
        alert(create_close_alert_message(sl_trade_id), alert.freq_once_per_bar)

if strategy.position_size < 0
    if high >= short_sl
        sl_trade_id := generate_trade_id("SL")
        pnl := ((entry_price - short_sl) / entry_price) * 100
        strategy.close("Short", comment=sl_trade_id)
        sl_exit_trigger := true
        alert(create_close_alert_message(sl_trade_id), alert.freq_once_per_bar)

// Move SL to BE after TP1
if tp1_hit and move_sl_to_be
    if strategy.position_size > 0 or strategy.position_size < 0
        sl_moved_to_be_trigger := true
        alert(create_move_sl_be_message(current_trade_id, strategy.position_size > 0), alert.freq_once_per_bar)

// Reset tracking when position closes
if strategy.position_size == 0 and strategy.position_size[1] != 0
    entry_price := na
    tp1_hit := false
    trade_entry_bar := na
    long_tp1 := na
    long_tp2 := na
    long_sl := na
    short_tp1 := na
    short_tp2 := na
    short_sl := na
    
    // mark position closed for built-in alerts
    position_closed_trigger := true

// ═══════════════════════════════════════════════════════════════════════════
// REDUNDANCY PROBES SYSTEM
// ═══════════════════════════════════════════════════════════════════════════

// Send repeated close alerts after trade exits
var int probe_count = 0

if probes_active and not na(last_probe_time)
    time_since_last_probe = (time - last_probe_time) / 1000 // Convert to seconds
    
    if time_since_last_probe >= time_between_probes
        // Create redundancy probe alert
        probe_trade_id = current_trade_id + "-PROBE" + str.tostring(probe_count + 1)
        
        alert_msg = '{'
        alert_msg := alert_msg + '"trade_id": "' + probe_trade_id + '", '
        alert_msg := alert_msg + '"action": "REDUNDANCY_PROBE", '
        alert_msg := alert_msg + '"probe_number": ' + str.tostring(probe_count + 1) + ', '
        alert_msg := alert_msg + '"original_trade": "' + current_trade_id + '", '
        alert_msg := alert_msg + '"direction": "' + last_trade_direction + '", '
        alert_msg := alert_msg + '"status": "CLOSED", '
        alert_msg := alert_msg + '"timestamp": ' + str.tostring(time)
        alert_msg := alert_msg + '}'
        
        if use_custom_alerts
            alert(alert_msg, alert.freq_once_per_bar)
        
        probe_count += 1
        last_probe_time := time
        
        // Stop probes after 5 iterations (customizable)
        if probe_count >= 5
            probes_active := false
            probe_count := 0

// ═══════════════════════════════════════════════════════════════════════════
// VISUALIZATION
// ═══════════════════════════════════════════════════════════════════════════

// Plot Distance Capture levels
plot(mode == "Distance Capture" ? dc_long_level : na, 
     "DC Long Level", color=color.new(color.green, 70), style=plot.style_circles)
plot(mode == "Distance Capture" ? dc_short_level : na, 
     "DC Short Level", color=color.new(color.red, 70), style=plot.style_circles)

// Plot TP/SL levels
plot(strategy.position_size > 0 ? long_tp1 : na, 
     "Long TP1", color=color.new(color.green, 0), linewidth=1, style=plot.style_cross)
plot(strategy.position_size > 0 ? long_tp2 : na, 
     "Long TP2", color=color.new(color.lime, 0), linewidth=1, style=plot.style_cross)
plot(strategy.position_size > 0 ? long_sl : na, 
     "Long SL", color=color.new(color.red, 0), linewidth=1, style=plot.style_cross)

plot(strategy.position_size < 0 ? short_tp1 : na, 
     "Short TP1", color=color.new(color.red, 0), linewidth=1, style=plot.style_cross)
plot(strategy.position_size < 0 ? short_tp2 : na, 
     "Short TP2", color=color.new(color.maroon, 0), linewidth=1, style=plot.style_cross)
plot(strategy.position_size < 0 ? short_sl : na, 
     "Short SL", color=color.new(color.green, 0), linewidth=1, style=plot.style_cross)

// Background color for Wide Tide mode
bgcolor(mode == "Wide Tide" and wide_tide_long ? color.new(color.green, 95) : na)
bgcolor(mode == "Wide Tide" and wide_tide_short ? color.new(color.red, 95) : na)

// Plot BROC angle for debugging
plot(use_broc ? broc_angle : na, "BROC Angle", color=color.new(color.purple, 0), display=display.data_window)
plot(use_uproc ? uproc_angle : na, "UPROC Angle", color=color.new(color.blue, 0), display=display.data_window)
plot(use_loroc ? loroc_angle : na, "LOROC Angle", color=color.new(color.orange, 0), display=display.data_window)

// Visual indicator for Marubozu candles
plotshape(use_marubozu and is_bullish_marubozu, "Bullish Marubozu", 
     shape.triangleup, location.belowbar, color=color.new(color.green, 0), size=size.tiny)
plotshape(use_marubozu and is_bearish_marubozu, "Bearish Marubozu", 
     shape.triangledown, location.abovebar, color=color.new(color.red, 0), size=size.tiny)

// Cooldown indicator (shows when cooldown is active)
bgcolor(use_cooldown and not cooldown_long_ok and not cooldown_short_ok ? 
     color.new(color.gray, 90) : na, title="Cooldown Active")

// Display current trade info in a table
var table info_table = table.new(position.top_right, 2, 6, border_width=1)

if barstate.islast and use_custom_alerts
    table.cell(info_table, 0, 0, "Trade Counter", text_color=color.white, bgcolor=color.blue)
    table.cell(info_table, 1, 0, str.tostring(trade_counter), text_color=color.white, bgcolor=color.blue)
    
    table.cell(info_table, 0, 1, "Current Trade ID", text_color=color.white, bgcolor=color.navy)
    table.cell(info_table, 1, 1, current_trade_id, text_color=color.white, bgcolor=color.navy)
    
    table.cell(info_table, 0, 2, "Position", text_color=color.white, bgcolor=color.navy)
    table.cell(info_table, 1, 2, current_position_side, text_color=color.white, bgcolor=color.navy)
    
    table.cell(info_table, 0, 3, "Mode Prefix", text_color=color.white, bgcolor=color.gray)
    table.cell(info_table, 1, 3, signal_prefix_mode, text_color=color.white, bgcolor=color.gray)
    
    table.cell(info_table, 0, 4, "TP1 Hit", text_color=color.white, bgcolor=color.gray)
    table.cell(info_table, 1, 4, tp1_hit ? "YES" : "NO", 
         text_color=color.white, bgcolor=tp1_hit ? color.green : color.red)
    
    table.cell(info_table, 0, 5, "Probes Active", text_color=color.white, bgcolor=color.gray)
    table.cell(info_table, 1, 5, probes_active ? "YES" : "NO", 
         text_color=color.white, bgcolor=probes_active ? color.orange : color.gray)

// ═══════════════════════════════════════════════════════════════════════════
// ALERT CONDITIONS (built-in alerts)
// ═══════════════════════════════════════════════════════════════════════════

// Note: Custom alerts are sent via alert() function in the execution logic above
// These alertcondition() calls are for TradingView's built-in alert system
// Add separate alertconditions for entries, exits, opens/closes, and SL-breakeven moves

alertcondition(entry_long_trigger, title="BBB3 Long Entry", message="")
alertcondition(entry_short_trigger, title="BBB3 Short Entry", message="")

alertcondition(tp1_exit_trigger, title="BBB3 TP1 Exit", message="")
alertcondition(tp2_exit_trigger, title="BBB3 TP2 Exit", message="")
alertcondition(sl_exit_trigger, title="BBB3 Stop Loss Exit", message="")

alertcondition(position_opened_trigger, title="BBB3 Position Opened", message="")
alertcondition(position_closed_trigger, title="BBB3 Position Closed", message="")

alertcondition(sl_moved_to_be_trigger, title="BBB3 SL Moved to BE", message="")

// Backwards-compatible simple alert names (kept for older usage)
alertcondition(execute_long, "Long Entry Signal", "BBB3 Long Entry")
alertcondition(execute_short, "Short Entry Signal", "BBB3 Short Entry")

// ═══════════════════════════════════════════════════════════════════════════
// END OF STRATEGY
// ═══════════════════════════════════════════════════════════════════════════